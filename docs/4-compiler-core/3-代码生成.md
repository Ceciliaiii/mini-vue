# 代码生成
是模板编译的最后一步，它把经过转化处理的 AST 树，转换成可执行的 `render` 函数字符串。

## 创建代码生成上下文
创建一个 “代码生成上下文”，相当于一个 “代码构建器”：
 - 记录正在生成的代码字符串（`code`）
 - 管理代码缩进（`level`），让生成的代码格式工整
 - 提供工具方法：添加代码（`push`）、缩进（`indent`）、换行（`newLine`）等
 - 处理辅助函数的命名（比如把 `CREATE_ELEMENT_VNODE` 转换成 `_createElementVNode`）  

处理 `<div>Hello {{ name }}</div>` 时，上下文初始状态：
```ts
{
  code: "",        // 空字符串，准备拼接代码
  level: 0,        // 初始缩进级别
  helper: 函数,    // 用于转换辅助函数名
  push: 函数,      // 用于添加代码片段
  // 其他方法...
}
```

## 生成函数前置代码：引入需要的工具
在`render`函数前，先引入需要的辅助函数（比如`createElementVNode、toDisplayString`），确保函数内可以正常调用。  
如果 AST 中用到了`TO_DISPLAY_STRING`和`CREATE_ELEMENT_BLOCK`，会生成：
```ts
const { 
    toDisplayString: _toDisplayString, 
    createElementBlock: _createElementBlock 
    } = Vue
```

## 生成`render`函数框架：搭建函数结构
根据 AST 中的`codegenNode`（转化阶段生成的虚拟节点指令），生成创建虚拟节点的代码。

### 文本节点（`NodeTypes.TEXT`）
直接把文本内容转换成字符串字面量。
```ts
{
  type: NodeTypes.TEXT,
  content: "Hello "
}
```
生成代码：
```ts
"Hello "
```

### 插值表达式（`NodeTypes.INTERPOLATION`）
把`插值name`转换成`_toDisplayString(_ctx.name)`，确保动态数据能正确显示。
```ts
{
  type: NodeTypes.INTERPOLATION,
  content: {
    type: NodeTypes.SIMPLE_EXPRESSION,
    content: "_ctx.name"
  }
}
```
生成：
```ts
_toDisplayString(_ctx.name)
```

### 虚拟节点调用（`NodeTypes.VNODE_CALL`）
生成创建虚拟节点的函数调用（比如`_createElementBlock`），包含标签名、属性、子节点等参数。
```ts
{
  type: NodeTypes.VNODE_CALL,
  tag: "div",
  props: null,
  children: [文本节点, 插值节点],
  isBlock: true,
  callee: CREATE_ELEMENT_BLOCK
}
```
生成代码：
```ts
(_openBlock(), 
_createElementBlock("div", null, "Hello " + _toDisplayString(_ctx.name))
)
```

## 整合：生成完整 `render` 函数
模板`<div>Hello {{ name }}</div>`最终生成的代码：
```ts
const { 
    toDisplayString: _toDisplayString, 
    openBlock: _openBlock, 
    createElementBlock: _createElementBlock 
} = Vue


return function render(_ctx) {
  return (_openBlock(), 
          _createElementBlock("div", null, "Hello " + _toDisplayString(_ctx.name))
  )
}
```