# 代码转化
把模板解析得到的 AST 树，加工成更接近最终渲染函数的结构.

## 创建转化上下文
创建一个转化上下文：
 - 记录当前处理的节点、父节点；
 - 保存需要用到的工具函数，比如 `createElementVnode`；
 - 存放对节点执行的转化规则；  

比如，解析 `<div>{{ name }}</div>` 得到的 AST 根节点，会先被存入上下文的 `currentNode` 中。


## 遍历 AST 节点
采用深度优先的方式遍历整个 AST 树：
 - 先处理当前节点，执行对应的转化规则；
 - 递归处理它的子节点；
 - 子节点处理完后，再做当前节点的收尾工作；  

比如上面的例子，会先处理根节点，再处理 `<div>` 元素节点，最后处理插值节点。



## 转化
### 处理元素节点
会生成创建虚拟节点的代码指令，比如 `createElementVNode('div', ...)`：
 - 记录标签名（比如 `div`）
 - 把属性转换成对象形式（比如 `class="red"` 变成 `{ class: 'red' }`）
 - 处理子节点（单个子节点直接用，多个子节点放数组里）  

原始元素节点：
```ts
{
  type: ELEMENT,
  tag: 'div',
  props: [{ name: 'class', value: 'box' }],
  children: [文本节点, 插值节点]
}
```
转化后，新增 `codegenNode`：
```ts
{
  type: VNODE_CALL,
  tag: 'div',
  props: { type: JS_OBJECT_EXPRESSION, properties: [...] },
  children: [...],
  callee: CREATE_ELEMENT_VNODE
}
```

### 处理文本和插值
主要做两件事：
 - 合并连续的文本和插值（比如 `"Hello"` 和 `插值name` 会合并成 `"Hello" + _ctx.name`）
 - 生成文本虚拟节点的代码指令（比如 `createTextVNode(...)`）  

两个连续节点：
```ts
[
  { type: TEXT, content: "Hello " },
  { type: INTERPOLATION, content: { content: "name" } }
]
```
转化后合并成：
```ts
{
  type: COMPOUND_EXPRESSION,
  children: [
    { type: TEXT, content: "Hello " },
    "+",
    { type: INTERPOLATION, content: { content: "_ctx.name" } }
  ]
}
```

### 处理插值表达式
把 `插值name` 转换成 `_ctx.name`，让他能正确访问组件数据。  
原始插值节点：
```ts
{
  type: INTERPOLATION,
  content: { type: SIMPLE_EXPRESSION, content: "name" }
}
```
转化后：
```ts
{
  type: INTERPOLATION,
  content: { type: SIMPLE_EXPRESSION, content: "_ctx.name" }
}
```

## 处理根节点：确定最终结构
根据根节点的子节点数量做不同处理：
 - **只有一个元素子节点**：标记为 “块”（block），支持靶向更新
 - **多个子节点**：用 Fragment 包裹  

根节点有多个子节点时：
```ts
{
  type: ROOT,
  children: [元素节点1, 元素节点2],
  codegenNode: {
    type: VNODE_CALL,
    tag: Fragment,
    children: [元素节点1, 元素节点2],
    callee: CREATE_ELEMENT_BLOCK
  }
}
```
最终，每个节点都有生成虚拟节点的指令 `codegenNode`，也记录了所有要用到的工具函数 `create...Vnode`。