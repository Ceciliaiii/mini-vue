# 靶向更新
为了解决 “微小的属性变化都要遍历整个子节点树” 的性能问题，在编译期提前识别并只更新动态内容

## `PatchFlag`：标记动态属性类型
是一个位枚举（通过位运算组合），用于标记 vnode 上 “哪些属性是动态的”，避免运行期遍历所有属性。  
在 `patchElement` 中，运行期会根据 `PatchFlag` 只比对 “标记过的动态属性”，跳过静态属性：
```ts
 // 有 PatchFlag：只比对标记的动态属性
  if (patchFlag) {

    // 若标记了 CLASS：只比对 class 属性
    if (patchFlag & PatchFlags.CLASS) {
      if (oldProps.class !== newProps.class) {
        hostPatchProp(el, newProps.class, oldProps.class);
      }
    }

    // 若标记了 STYLE：只比对 style 属性
    if (patchFlag & PatchFlags.STYLE) {
      hostPatchProp(el, newProps.style, oldProps.style);
    }

    // 若标记了 TEXT：只比对文本内容（跳过子节点全量 diff）
    if (patchFlag & PatchFlags.TEXT) {
      if (n1.children !== n2.children) {
        return hostSetElementText(el, n2.children); // 直接更新文本，不执行全量 diff
      }
    }
  } 
  else {
    // 无 PatchFlag：执行全量属性比对（兼容未编译的场景）
    patchProps(oldProps, newProps, el);
  }
```


## `dynamicChildren`：标记动态子节点
`dynamicChildren` 是一个数组，用于收集 vnode 下 “所有动态子节点”，避免运行期遍历所有子节点（包括静态子节点）。

### 编译期
编译期会通过 `openBlock、closeBlock、setupBlock` 三个函数 “收集动态子节点”：
```ts
let currentBlock = null; // 临时存储当前块的动态子节点

// 1. 开启块：初始化动态子节点收集容器
export function openBlock() {
  currentBlock = [];
}

// 2. 关闭块：停止收集
export function closeBlock() {
  currentBlock = null;
}

// 3. 构建块：将收集到的动态子节点挂载到 vnode 上
export function setupBlock(vnode) {
  vnode.dynamicChildren = currentBlock; // 动态子节点数组赋值给 vnode
  closeBlock();
  return vnode;
}

// 4. 创建带块标记的元素 vnode（编译期会调用此函数）
export function createElementBlock(type, props, children, patchFlag?) {
  return setupBlock(createVnode(type, props, children, patchFlag));
}
```


### 运行期
在 `patchElement` 中，若 vnode 有 `dynamicChildren`，则执行 “靶向子节点更新”；
```ts
// patchElement

 // 有 dynamicChildren：只更新动态子节点（靶向更新）
  if (dynamicChildren) {
    patchBlockChildren(n1, n2, el, anchor, parentComponent);
  } 
  else {
    // 无 dynamicChildren：执行全量子节点 diff（旧逻辑）
    patchChildren(n1, n2, el, anchor, parentComponent);
  }
```
`patchBlockChildren` 只比对动态子节点，跳过静态子节点：
```ts
// 靶向更新子节点：只遍历 dynamicChildren 数组，线性比对
const patchBlockChildren = (n1, n2, el, anchor, parentComponent) => {
    
  // 线性比对动态子节点（无需全量 diff，因为编译期已保证顺序）
  for (let i = 0; i < n2.dynamicChildren.length; i++) {
    patch(n1.dynamicChildren[i], n2.dynamicChildren[i], el, anchor, parentComponent);
  }
};
```
例如：
```html
<div>
    <span>静态文本</span>
    {{ dynamicText }}
    <p>静态段落</p>
</div>
```
`dynamicChildren` 只包含 dynamicText 对应的文本 vnode，运行期只会更新这个文本节点，跳过静态标签。


## 其他优化
### block 标签变化
最外层 block 收集子 block，通过 key = 0/1 来控制，若 key 不一样，则重新创建。例如：
```html
<div>
    <div v-if='a === true'>
        <span>{{ dynamicText }}</span>
    </div>
    <p v-else>
         <span>{{ dynamicText }}</span>
    </p>
</div>
```

### 多层 block 嵌套
同上，通过 key = 0/1 来控制创建 v-if 或 v-else。
```html
<div>
    <div v-if='a === true'>
         <span>{{ dynamicText }}</span>
    </div>
    <p v-else>
        <p>
          <span>{{ dynamicText }}</span>
        </p>
    </p>
</div>
```


### v-for
靶向更新的前提是更新前后的节点能一一对应，而 `v-for` 之后的节点 item 不稳定，其 block 的所有子节点 item 不收集到 `dynamicChildren`，而是放进 `children` 中用全量 diff 做比对，给 `v-for` 的 block 用 `fragment` 包裹起来，只需要更新 `fragment` 即可。
```html
<div>
    <div v-for="item in count">
         {{ item }}
    </div>
</div>
```
只有在确定 `count` 值后，item 才会稳定，将所有 item 放进 `dynamicChildren` 用线性比对
```html
<div>
    <div v-for="item in 3">
         {{ item }}
    </div>
</div>
```

### 静态提升
在编译期，提升静态节点以复用，优化性能；
```html
<div>
    <span>静态文本</span>
    {{ dynamicText }}
</div>
```

### 预字符串
相同的静态节点超过20个，将静态节点转化为一个长字符串并提升；

### 缓存函数
提升函数，用于复用，例如更新前后复用 onClick，则将其提升并缓存