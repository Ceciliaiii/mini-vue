# 比较策略
复用可复用的 DOM 元素，只更新有差异的部分

## `isSameVnode`：判断是否为“可复用元素”
判断新旧虚拟节点（n1、n2）是否对应同一个真实 DOM 元素，决定 “复用元素” 还是 “销毁重建”：
```ts
export function isSameVnode(n1, n2) {
  // 两个条件同时满足才视为“可复用”：
  // 1. 节点类型相同（如都是 'div' 标签）
  // 2. key 相同（key 是节点的唯一标识，用于精准匹配）
  return n1.type === n2.type && n1.key === n2.key
}
```

## `patchElement`：元素比较
 - `c1, c2`：老新节点的子节点（n.children）
 - `prevShapeFlag, shapeFlag`：老新节点的子节点类型（文本 / 数组）

### 复用 DOM 元素
元素可复用时（n1 和 n2 是同一节点），只更新属性
```ts
const patchElement = (n1, n2, container) => {
  // 让新虚拟节点（n2）关联老节点的真实 DOM（n1.el）
  // 避免重新创建 DOM，直接复用已有元素
  let el = (n2.el = n1.el)  
  // ...后续更新属性和子节点
}
```


###  比较并更新属性（patchProps）
对比新旧节点的 props，只更新变化的属性
```ts
const patchProps = (oldProps, newProps, el) => {

  // 1. 应用新属性：新属性全量生效（新增/覆盖老属性）
  for(let key in newProps) {
    hostPatchProp(el, key, oldProps[key], newProps[key])
  }

  // 2. 清理老属性：老属性存在但新属性没有，移除该属性
  for(let key in oldProps) {
    if(!(key in newProps)) {
      hostPatchProp(el, key, oldProps[key], null)
    }
  }
}
```


## `patchChildren`：子节点比较
根据 “新旧子节点的类型”（文本 / 数组）分场景处理。通过 `shapeFlag`（节点类型标记）判断子节点类型，覆盖 6 种场景：

### 新子节点是文本（shapeFlag & TEXT_CHILDREN）
```ts
if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {

  // 老子节点是数组 → 先删除老数组子节点
  if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {
    unmountChildren(c1) // 批量移除老DOM子元素
  }

  // 老子节点是文本且内容不同 → 直接替换文本
  if (c1 !== c2) {
    hostSetElementText(el, c2) // 覆盖元素文本，无DOM增删
  }
}
```

### 新子节点不是文本（数组 / 空）
```ts
else {
  // 老子节点是数组
  if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {

    // 新子节点也是数组 → 后续走“全量diff算法”比对数组
    if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {

      // （代码中待实现：数组diff，如key匹配复用子节点）
    }

    // 新子节点不是数组（空） → 删除老数组子节点
    else {
      unmountChildren(c1)
    }
  }

  // 老子节点是文本
  else {

    // 先清空老文本
    if (prevShapeFlag & ShapeFlags.TEXT_CHILDREN) {
      hostSetElementText(el, '') // 清空元素文本
    }

    // 新子节点是数组 → 挂载新数组子节点
    if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {
      mountChildren(c2, el) // 批量创建并插入新DOM子元素
    }
  }
}
```