# 函数式组件
无状态、无实例的轻量级组件，它本质上就是一个纯函数，接收 props 并返回虚拟节点；

## 类型标记（ShapeFlags）
在创建虚拟节点时，函数式组件会被标记为` ShapeFlags.FUNCTIONAL_COMPONENT`，与有状态组件区分开：
```ts
// 确定组件类型并标记
const shapeFlag = isString(type) ? 
    ShapeFlags.ELEMENT : isObject(type) ? 
     // 有状态组件（如对象形式定义的组件）
    ShapeFlags.STATEFUL_COMPONENT : isFunction(type) ?  
    // 函数式组件（函数形式定义的组件）
    ShapeFlags.FUNCTIONAL_COMPONENT : 0; 
      
```


## 渲染（renderComponent）
根据组件类型（有状态 / 函数式）执行不同的渲染逻辑：
```ts
function renderComponent(instance) {
  const { render, vnode, proxy, attrs } = instance;

    // 有状态组件
  if (vnode.shapeFlag & ShapeFlags.STATEFUL_COMPONENT) {

    // 通过 render 方法渲染（绑定 proxy 作为 this）
    return render.call(proxy, proxy);
  } 
  
  //  函数式组件
  else {

    // 直接调用组件函数，传入 attrs 作为参数
    return vnode.type(attrs);  // vnode.type 就是函数式组件本身（纯函数）
  }
}
```
函数式组件不需要实例和 proxy，直接执行函数并传入属性即可


## 更新（componentUpdateFn）
函数式组件 与 有状态组件，共用同一个更新函数：
```ts
if (!instance.isMounted) {
    // 首次渲染
    // ...
    
    // 渲染函数式组件：调用 renderComponent 得到子树
    const subTree = renderComponent(instance);
    patch(null, subTree, container, anchor);
    instance.isMounted = true;
    instance.subTree = subTree;
    
    // ...
  } 
  else {
    // 更新时
    // ...
    
    // 重新渲染函数式组件（仅依赖 attrs，无内部状态）
    const subTree = renderComponent(instance);
    patch(instance.subTree, subTree, container, anchor);
    instance.subTree = subTree;
    
    // ...
  }
```