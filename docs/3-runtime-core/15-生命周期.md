# 生命周期
逻辑分为 “钩子注册” “时机触发” “实例校正” 三部分，代码中通过 `createHook、componentUpdateFn、currentInstance` 协同实现。


## `createHook`：钩子注册（生命周期中用户定义的逻辑）
将定义的钩子，绑定到当前组件实例 currentInstance 的对应生命周期数组中；  
统一管理生命周期类型：
```ts
// 生命周期枚举（如 BEFORE_MOUNT 对应 "bm"）
export const enum LifeCycle {
    BEFORE_MOUNT = 'bm',
    MOUNTED = 'm',
    BEFORE_UPDATE = 'bu',
    UPDATE = 'u'
}
```
创建生命周期钩子：
```ts
function createHook(type) {
    
    // hook：开发者定义的回调函数；   target：默认是当前组件实例（currentInstance）
    return (hook, target = currentInstance) => {

        if (target) { // 确保在组件实例内注册（避免全局调用）

            // 1. 给组件实例添加“生命周期数组”（如 target.bm 存储所有 beforeMount 钩子）
            const hooks = target[type] || (target[type] = []);

            // 2. 包装钩子：执行时校正当前实例（避免实例丢失）
            const wrapHook = () => {

                // 执行前绑定实例到 currentInstance
                setCurrentInstance(target); //  setup 执行完会清空实例  再次绑定当前实例
                hook.call(target);          // 执行钩子，this 指向组件实例
                unsetCurrentInstance();     // 执行后清空实例，避免污染
            };

            // 3. 将包装后的钩子加入实例的生命周期数组
            hooks.push(wrapHook);
        }
    };
}

// 生成具体的生命周期API（如 onBeforeMount 对应 BEFORE_MOUNT 类型）
const onBeforeMount = createHook(LifeCycle.BEFORE_MOUNT);
const onMounted = createHook(LifeCycle.MOUNTED);
const onBeforeUpdate = createHook(LifeCycle.BEFORE_UPDATE);
const onUpdated = createHook(LifeCycle.UPDATE);
```
`currentInstance` 是 “全局变量”，会在多组件并发时动态变化，并且 `setup` 执行完会清空实例，影响后续钩子 "可能再次获取实例"；  
`wrapHook` 保证了执行钩子前的 `target` 是当前正确的实例，然后马上执行钩子，再清空当前组件实例，避免污染其他组件钩子


## 时机触发
在 `componentUpdateFn` 中挂载和更新组件，挂载时：
```ts
// 从实例中获取生命周期钩子数组（bm=beforeMount，m=mounted等）

// 钩子数组存放着 各种用户定义的逻辑和方法
 const { bm, m, bu, u } = instance; 

    // 1. 首次挂载阶段
    if (!instance.isMounted) {

        // 挂载前：执行 beforeMount 钩子（bm 数组）
        if (bm) invokeArray(bm);

        // 渲染DOM（生成subTree并patch到页面）
        const subTree = render.call(instance.proxy, instance.proxy);
        patch(null, subTree, container, anchor);
        instance.isMounted = true;
        instance.subTree = subTree;

        // 挂载后：执行 mounted 钩子（m 数组）
        if (m) invokeArray(m);
    } 
```

更新时：
```ts
    // 2. 组件更新阶段
    else {
        // 更新前：执行 beforeUpdate 钩子（bu 数组）
        if (bu) invokeArray(bu);

        // 重新渲染DOM（对比新旧subTree并更新）
        const subTree = render.call(instance.proxy, instance.proxy);
        patch(instance.subTree, subTree, container, anchor);
        instance.subTree = subTree;

        // 更新后：执行 updated 钩子（u 数组）
        if (u) invokeArray(u);
    }


// 辅助函数：批量执行钩子数组中的所有函数
export function invokeArray(fns) {
    for (let i = 0; i < fns.length; i++) {
        fns[i]();
    }
}
```


## 实例校正
通过 `setCurrentInstance` 和 `unsetCurrentInstance` 管理实例上下文：
```ts
// 全局变量：存储当前正在执行的组件实例
export let currentInstance = null;

// 设置当前实例（在 setup 执行前调用）
export const setCurrentInstance = (instance) => {
  currentInstance = instance;
};

// 清空当前实例（在 setup 执行后或钩子执行后调用）
export const unsetCurrentInstance = () => {
  currentInstance = null;
};



// setup 执行时绑定实例（确保注册钩子时 target 是当前实例）
setCurrentInstance(instance);
const setupResult = setup(instance.props, setupContext); // setup 中注册的钩子会关联 currentInstance
unsetCurrentInstance();
```