# Text & Fragment 节点渲染

## Text：纯文本的渲染处理
### `processText`
直接操作浏览器文本节点 API，处理 Text 节点的 “初始化渲染” 和 “更新”
```ts
// 初始化
if (n1 == null) {
  // 1. 调用 hostCreateText（对应 document.createTextNode）创建真实文本节点
  // 2. 给新虚拟节点（n2）关联真实文本节点      （n2.el = 真实节点）
  // 3. 调用 hostInsert（对应 parent.insertBefore）插入到容器中
  hostInsert(n2.el = hostCreateText(n2.children), container);
}

// 重渲染
else {
  // 1. 复用老节点的真实文本节点   （n2.el = n1.el，避免重新创建）
  const el = (n2.el = n1.el);
  
  // 2. 若新旧文本内容不同，更新真实文本节点内容
  if (n1.children !== n2.children) {
    hostSetText(el, n2.children);
  }
}
```
文本更新时只修改已有文本节点的 `nodeValue`，不删除重建


## Fragment：多节点的聚合渲染
### `processFragment`
只渲染其内部子节点，自身不生成真实 DOM 元素，子节点的父元素是容器本身，而非 Fragment
```ts
// 初始化
if (n1 == null) {
  // 直接挂载 Fragment 的子节点到容器，不处理 Fragment 自身
  mountChildren(n2.children, container);
}


// 重渲染
else {
  // 对比新旧 Fragment 的子节点差异，只更新变化的子节点
  patchChildren(n1, n2, container);
}
```
```ts
// 卸载渲染
const unmount = (vnode) => {
  if (vnode.type === Fragment) {
    // 卸载 Fragment 时，只卸载其内部子节点
    unmountChildren(vnode.children);
  } else {
    hostRemove(vnode.el);
  }
};
```