# 清理函数：onCleanup & unwatch


## onCleanup
在 `watch` 或 `watchEffect` 中，副作用函数的第三个参数方法，通过 `onCleanup` 注册清理函数，用于在副作用执行前**清理上一次的副作用残留**。

### 使用场景
 - **清除定时器**：避免多次执行导致定时器累积，详情见使用示例。
 - **取消网络请求**：避免旧请求返回覆盖新请求结果。
 - **移出事件监听**：防止事件监听重复绑定。


### 核心
```ts
// 在 doWatch 中定义清理相关逻辑
let clean
const onCleanup = (fn) => {
  clean = () => {
    fn() // 执行用户定义的清理逻辑
    clean = undefined // 清理后重置
  }
}


// 在 job 中执行清理
const job = () => {
  if(cb) {
    const newValue = effect.run()

    if(clean) {
      clean() // 执行上一次注册的清理函数
    }
    cb(newValue, oldValue, onCleanup) // 将 onCleanup 传递给用户回调
    oldValue = newValue
  }
  // ...
}
```


### 执行流程
1. 注册清理函数：  
用户在回调中通过 `onCleanup(fn)` 注册清理逻辑，此时 `clean` 变量会指向一个包裹 `fn` 的函数。
2. 清理时机：  
当副作用（watch 回调）即将重新执行时（即 `job` 函数触发时），会先检查是否存在 `clean` 函数：
    - 若存在，则执行 `clean()`，触发用户定义的清理逻辑
    - 执行后重置 `clean` 为 `undefined`，避免重复清理
3. 停止监听时的清理



## unwatch
unwatch 是 watch 或 watchEffect 函数的**返回值**，用于手动停止监听响应式数据的变化。
```ts
// 在doWatch函数中定义 并返回unwatch

const unwatch = () => {
  effect.stop() // 调用effect的stop方法停止响应式关联
}

return unwatch // 返回unwatch方法
```

### 核心
通过 `effect.stop()` 实现，具体逻辑在 ReactiveEffect 类中：
```ts
// ReactiveEffect

stop() {
  if(this.active) {
    this.active = false // 标记为非激活状态
    preCleanEffect(this) // 清理前置工作
    postCleanEffect(this) // 清理依赖关系
  }
}
```
本质是将 effect 标记为 `active = false`，不再响应数据变化；  
通过 `preCleanEffect` 和 `postCleanEffect` 清理 effect 和所有依赖数据的关联映射；  
清理后，数据变化不会再触发对应的副作用（watch 回调）
