# 防止递归调用 & 深度代理

## 防止递归调用
防止了 **"effect 执行 → 修改数据 → 触发自身再次执行"** 的递归调用问题
### 标记时执行
通过新增 `_running` 属性，标记当前 effect 是否正在执行；`0`为未执行，`1`为正在执行
```ts
run() {
  try {
    // ...其他逻辑
    this._running++  // 开始执行时，计数器+1
    return this.fn(); // 执行用户函数（可能触发数据更新）
  } finally {
    this._running--  // 执行结束后，计数器-1
    // ...其他逻辑
  }
}
```
执行结束后，`_running` 恢复为0

### 触发时检查
```ts
export function triggerEffects(dep) {
  for(const effect of dep.keys()) {
    // 核心判断：如果 effect 正在执行（_running > 0），则不触发调度器
    if(!effect._running) {

      if(effect.scheduler) {
        effect.scheduler()
      }
    }
  }
}
```

## 深度代理
```ts
let res = Reflect.get(target, key, recevier)

// 如果获取到的值是对象，递归进行代理
if(isObject(res)) {
    return reactive(res)
}
```

### 懒代理
按需进行，只有访问嵌套对象时，才为其创造代理
 - 例如 `const obj = reactive({ x, y, a: { b: 1 } })`
 - 初始时只会代理`x, y`，a 属性对应的对象 `{ b: 1 }` 不会立即被代理
 - 当第一次访问 `obj.a` 时，才会触发 `get` 方法，对 `{ b: 1 }` 进行代理