# 依赖清理

## 机制
当 effect 函数重新执行时，需要移除不再使用的依赖关系：
```ts
effect(() => {
    app.innerHTML = state.flag ? state.name : state.age
})
```

```ts
// 映射表
{ obj: { flag: {effect}, name: {effect} } }

// flag = false后
// 将name切换为age后，只访问了age并没有清理掉name的依赖
{ obj: { flag: {effect}, name: {effect}, age: {effect} } }
```
导致name的依赖没有被清理，后续会出现修改属性触发此effect（三个数据）的情况

## `preCleanEffect`：effect 重新执行前，进行预清理
应对循环依赖的情况：
 - 比如 effect 中用到 a，a每次变化都会触发 effect；我们需要在依赖存在的情况下，数据变化也不触发 effect，只有在访问属性时才触发
 - `_trackId` 的自增机制能避免无限循环（每次执行都是新的 ID，不会重复处理）。
```ts
function preCleanEffect(effect) {
  effect._depsLength = 0; // 重置依赖计数器
  effect._trackId++; // 执行次数+1（相当于给这次执行盖个新章）
}
```

## 重新执行 effect 函数，收集新依赖
```md
假设：
旧依赖 [depA, depB]
新依赖 [depA, depC]
```

```ts
export function trackEffect(effect, dep) {
  // 关键判断：当前依赖是否是这次执行需要的（用_trackId判断）
  if(dep.get(effect) !== effect._trackId) {

    // 1. 更新依赖中的记录（盖上新章）
    dep.set(effect, effect._trackId);

    // 2. 检查当前位置是否已有旧依赖
    let oldDep = effect.deps[effect._depsLength]; 
    if(oldDep !== dep) { // 如果同一位置的旧依赖和新依赖不一样
      if(oldDep) {
        // 清理旧依赖（从dep中移除这个effect）
        cleanDepEffect(oldDep, effect);
      }
      // 记录新依赖
      effect.deps[effect._depsLength++] = dep;
    } 
    else {
      // 同一位置的新旧依赖没变，只更新计数器
      effect._depsLength++;
    }
  }
  // ...
}
```

## `postCleanEffect`：执行后的清理收尾
effect 函数执行完后，调用 `postCleanEffect` 处理旧dep残留的旧依赖
```ts
function postCleanEffect(effect) {

  // 如果实际依赖数量比新统计的多，说明有旧依赖需要清理
  if(effect.deps.length > effect._depsLength) {

    // 遍历剩下的旧依赖
    for(let i = effect._depsLength ; i < effect.deps.length ; i++) {
      cleanDepEffect(effect.deps[i], effect); // 从dep中移除effect
    }

    // 截断数组，只保留新依赖
    effect.deps.length = effect._depsLength;
  }
}
```

## `cleanDepEffect`：具体清理操作

 - 从 `dep` 中移除当前 `effect`，这样数据变化时就不会再通知它了
 - 如果一个 `dep` 已经没有任何 `effect` 依赖它了，就把这个 `dep` 从 `depsMap` 中删除，释放内存

```ts
function cleanDepEffect(dep, effect) {
  dep.delete(effect); // 从dep的映射表中移除这个effect
  
  // 如果dep里已经没有任何effect了，就把这个dep也删掉
  if(dep.size == 0) {
    dep.cleanup(); // 调用创建dep时定义的清理函数（删除depsMap中的记录）
  }
}
```

## 完整流程

 - **准备阶段**：重置计数器，更新执行 ID
 - **收集阶段**：重新收集依赖，实时清理明显的旧依赖
 - **收尾阶段**：批量清理未被重新收集的残留旧依赖
 - **彻底清理**：如果依赖不再被任何 effect 使用，就删除整个依赖记录