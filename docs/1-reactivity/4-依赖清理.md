# 依赖清理

## 机制
当 effect 函数重新执行时，需要移除不再使用的依赖关系：
```ts
effect(() => {
    app.innerHTML = state.flag ? state.name : state.age
})
```

```ts
// 映射表
{ obj: { flag: {effect}, name: {effect} } }

// flag = false后
// 将name切换为age后，只访问了age并没有清理掉name的依赖
{ obj: { flag: {effect}, name: {effect}, age: {effect} } }
```
导致name的依赖没有被清理，后续会出现修改属性触发此effect（三个数据）的情况

## `preCleanEffect`：effect 重新执行前，进行预清理
循环依赖的情况：
 - 自循环：effect 中用到 a，a每次变化都会触发 effect，`effect -> a -> effect`。
 - 双向循环：effectA 依赖数据 a，a 的变化触发 effectB；effectB 依赖数据 b，b 的变化又触发 effectA，形成相互触发的循环，`effectA -> a -> effectB -> b -> effectA`。
 - 间接循环：`effect1 → y → effect2 → z → effect3 → x → effect1`
 - 嵌套循环：...
```ts
// `_trackId` 的自增机制能避免无限循环（每次执行都是新的 ID，不会重复处理）。

function preCleanEffect(effect) {
  effect._depsLength = 0; // 重置依赖计数器 (依赖集的索引)
  effect._trackId++; // 执行次数+1（相当于给这次执行盖个新章）
}
```

## 重新执行 effect 函数，收集新依赖
做一个简易的diff算法，区分新旧依赖集deps
```md
假设：
旧依赖 [depA, depB]
新依赖 [depA, depC]

都是在 一个依赖集 完成，拆开只是为了方便对比
```

```ts
export function trackEffect(effect, dep) {
  // 关键判断：当前依赖是否是这次执行需要的（用_trackId判断）
  if(dep.get(effect) !== effect._trackId) {

    // 1. 更新依赖中的记录，更新依赖集合中 effect 的标识值
    // / 用新 _trackId 覆盖旧 effect 执行记录，effect依赖执行次数
    dep.set(effect, effect._trackId);

    // 2. 检查当前位置是否已有旧依赖
    let oldDep = effect.deps[effect._depsLength]; 

    // 如果同一位置的旧依赖和新依赖不一样 例如旧的是depB，新的是depC
    // 始终都在一个依赖集完成
    if(oldDep !== dep) { 

      // 若该位置有旧依赖，删了再新增
      if(oldDep) {
        // 清理旧依赖depB（从dep中移除这个effect）
        cleanDepEffect(oldDep, effect);
      }

      // 若该位置没有依赖则直接新增，例如 [depA, null]
      // 记录新依赖depC
      effect.deps[effect._depsLength++] = dep;
    } 
    else {
      // 同一位置的新旧依赖没变，例如依赖中已经有旧的depA，就不需要重新收集
      // 只更新计数器，下一位
      effect._depsLength++;
    }
  }

}
```

对于第一处判断与`dep.set`：
 - 首次执行 effect 时，`_trackId = 1`，依赖 obj.a，depB 中记录 `{ effect: 1 }`。
 - 当 effect 重新执行并收集新依赖时，会用新的 `_trackId`（自增）更新新依赖的 dep（如 `depC.set(effect, 2)`）。
 - 对于旧依赖的 dep（如 depB），由于 effect 本次执行未访问它，其存储的 `_trackId` 仍为旧值 1。
 - 清理阶段遍历 effect 关联的所有 dep 时，若发现 `dep.get(effect) !== effect._trackId`（1 !== 2），则判定该 dep 已不再是当前依赖，执行 dep.delete(effect) 移除无效关联。


## `postCleanEffect`：执行后的清理收尾
```md
假设：
旧依赖 [depA, depB, depC, depD, depE, ...]
新依赖 [depA, depB]

都是在 一个依赖集 完成，拆开只是为了方便对比
```

effect 函数执行完后，调用 `postCleanEffect` 处理旧dep残留的旧依赖
```ts
function postCleanEffect(effect) {

  // 如果实际依赖数量比新统计的多，说明有旧依赖需要清理
  if(effect.deps.length > effect._depsLength) {

    // 遍历剩下的旧依赖
    for(let i = effect._depsLength ; i < effect.deps.length ; i++) {
      cleanDepEffect(effect.deps[i], effect); // 从dep中移除effect
    }

    // 截断数组，只保留新依赖
    effect.deps.length = effect._depsLength;
  }
}
```

## `cleanDepEffect`：具体清理操作

 - 从 `dep` 中移除当前 `effect`，这样数据变化时就不会再通知它了
 - 如果一个 `dep` 已经没有任何 `effect` 依赖它了，就把这个 `dep` 从 `depsMap` 中删除，释放内存。例如：
 ```md
· 响应式数据 { count = 0 }，count属性对应depA

· 最初有两个 effect 依赖count，depA中记录了这两个effect

· 后来 effect1 因组件卸载被清理，effect2 因逻辑修改不再依赖count

· 最终depA中的两个effect都被移除，变成空集合

· 此时 cleanDepEffect 会发现 depA.size === 0，调用 depA.cleanup() 彻底删除空依赖
 ```

```ts
function cleanDepEffect(dep, effect) {
  dep.delete(effect); // 从dep的映射表中移除这个effect
  
  // 如果dep里已经没有任何effect了，就把这个dep也删掉
  if(dep.size == 0) {
    dep.cleanup(); // 调用创建dep时定义的清理函数（删除depsMap中的记录）
  }
}
```

## 完整流程

 - **准备阶段**：重置计数器，更新执行 ID
 - **收集阶段**：重新收集依赖，实时清理明显的旧依赖
 - **收尾阶段**：批量清理未被重新收集的残留旧依赖
 - **彻底清理**：如果依赖不再被任何 effect 使用，就删除整个依赖记录