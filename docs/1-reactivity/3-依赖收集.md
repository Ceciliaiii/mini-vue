# 依赖收集

## 是什么
记录 **"谁用到了哪些数据"**
在 Vue 中，"谁" 就是我们写的 `effect` 函数（比如组件渲染函数），"哪些数据" 就是响应式对象的属性 `key`。当数据变化时，Vue 能精准找到用到这些数据的 `effect` 并重新执行。
 - 根据以下为例：
```ts
const state = reactive({
  name: 'czx',
  age: 20
})

effect(() => {
  app.innerHTML = `姓名${state.name}，年龄是${state.age}`
})

// 多次访问state.name
effect(() => {
    app.innerHTML = `姓名${state.name}`
})
```

## 核心工具：存储依赖关系的数据结构（映射表 `Map`）
想象成一个三层的 "账本"：
```md
    targetMap（ WeakMap ）：记录所有响应式对象的依赖
    │
    ├─ target1（响应式对象） → depsMap1（Map）
    │  │
    │  ├─ key1（对象属性） → dep1（Map）：记录用到 key1 的所有 effect
    │  └─ key2 → dep2：记录用到 key2 的所有 effect
    │
    └─ target2 → depsMap2
       │
       └─ key3 → dep3：记录用到 key3 的所有 effect
```

 - `targetMap`：总账本，按响应式对象（target）分类；根据以上访问示例，数据结构类似：
 ```ts
{
    {name: "czx", age: 20}: {
        name: {
              effect 1,
              effect 2
        },
        age: {
              effect 1
        }
    }
}
 ```

 - `depsMap`：子账本，按对象的属性（key）分类
 - `dep`：具体记录，记录哪些 effect 用到了这个属性


## `track`：收集依赖的过程
读取响应式对象属性时，就会触发流程
 1. 检查当前是否有活跃的 effect
    - 只有在 `effect` 函数内部读取数据，才需要记录依赖
    - `activeEffect` 就像一个 "正在工作的员工证"，有它才说明需要记录
 2. 创建或获取账本
 
 ```ts
    // track()

    // 检查 target 是否已有账本，没有就新建
    let depsMap = targetMap.get(target)
    if(!depsMap) {
    targetMap.set(target, (depsMap = new Map()))
    }

    // 检查 key 是否已有记录，没有就新建
    let dep = depsMap.get(key)
    if(!dep) {
    depsMap.set(key, (dep = createDep(...)))
    }
 ```

 3. 记录依赖关系

 ```ts
// 把当前 effect 加到 dep 里（这个 key 被这个 effect 用到了）
trackEffect(activeEffect, dep)

// 同时在 effect 里也记录 dep（双向记录，方便后续清理）
effect.deps.push(dep)
 ```

 ### 通俗例子

 当 `effect(() => { console.log(user.name) })` 执行时：
  - 读取 `user.name` 触发 `track`
  - 账本上会记录：`user` 对象 → `name` 属性 → 这个 `effect`


## `trigger`：触发更新的过程 
当你修改响应式对象的属性时, 会触发这个流程：

1. 先修改属性值
```ts
let oldValue = target[key]
let result = Reflect.set(target, key, value, recevier)
```

2. 判断值是否真的变了
```ts
if(oldValue !== value) {
    // 需要触发页面更新
    trigger(target, key, value , oldValue)
}
```

3. 查找并执行相关 effect
```ts
// trigger()

// 从账本中找到这个属性对应的所有 effect
const depsMap = targetMap.get(target)
let dep = depsMap.get(key)

// 如果有相关 effect，就执行它们
if(dep) {
  triggerEffects(dep)
}
```

4. 执行 effect
 - 遍历 dep 中记录的所有 effect
 - 调用每个 effect 的 `scheduler`（默认就是重新执行 effect 函数）
```ts
function triggerEffects(dep) {
  for(const effect of dep.keys()) {
    if(effect.scheduler) {
      effect.scheduler()
    }
  }
}
```


### 通俗例子
当 `user.name` 变化时:
 - 从账本中找到 `user → name` 对应的所有 effect
 - 逐个通知这些 effect："name 变了，快重新执行！"

## 双向记录
在 `trackEffect` 中，不仅 `dep` 记录了 `effect`，`effect` 也记录了 `dep`：
 - dep → effect：方便数据变化时快速找到要更新的 effect
 - effect → dep：方便后续清理:
 - 比如组件卸载时，让副作用能快速找到自己所有的依赖，在不需要时一次性清理干净，避免内存泄漏
 - 一个 effect 函数里可以用到多个响应式数据的属性，例如：
 ```ts
// 创建两个响应式对象
const user = reactive({ name: "张三", age: 20 });
const settings = reactive({ theme: "light" });

// 一个 effect 依赖了 3 个数据属性
effect(() => {
  console.log(`用户${user.name}（${user.age}岁），使用${settings.theme}主题`);
});

// 修改其中任意属性都会触发 effect 重新执行
// 故只需遍历 effect.deps 数组，就能一次性找到并移除这 3 个依赖关系
 ```


## 完整流程

1. **初始化**：执行 effect 函数，内部读取响应式数据
2. **收集依赖**：触发 `get` 拦截器 → 调用 `track` → 记录 "数据 - effect" 关系
3. **数据变化**：修改响应式数据，触发 `set` 拦截器
4. **触发更新**：调用 `trigger` → 找到相关 effect → 重新执行